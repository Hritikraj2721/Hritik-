pip install speechrecognition pyaudio pyttsx3 openai
# Windows (PowerShell)
setx OPENAI_API_KEY "your-real-key-here"

# macOS / Linux (bash/zsh)
export OPENAI_API_KEY="your-real-key-here"
"""
Jarvis: Voice + GUI + AI + simple personalization in one file.

Features:
- Tkinter GUI: shows status, what you said, and Jarvis's reply
- Microphone input on button press (Press 'Listen')
- Uses Google Web Speech via SpeechRecognition for STT
- Uses pyttsx3 for offline TTS
- Uses OpenAI Chat Completions for intelligence
- Simple JSON memory: remembers your name and some 'I like ...' facts between runs
"""

import os
import json
import threading
import speech_recognition as sr
import pyttsx3
import tkinter as tk
from tkinter import scrolledtext
from openai import OpenAI

# ------------- CONFIG -------------

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
MODEL_NAME = "gpt-4o-mini"  # use any chat model you have access to

MEMORY_FILE = "jarvis_memory.json"

if not OPENAI_API_KEY:
    raise RuntimeError("Please set OPENAI_API_KEY environment variable before running Jarvis.")

# ------------- AI CLIENT & MEMORY -------------

client = OpenAI(api_key=OPENAI_API_KEY)

def load_memory():
    """Load simple JSON memory from disk."""
    if not os.path.exists(MEMORY_FILE):
        return {"user_name": None, "facts": []}
    try:
        with open(MEMORY_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {"user_name": None, "facts": []}

def save_memory(memory):
    """Save memory dict to JSON."""
    with open(MEMORY_FILE, "w", encoding="utf-8") as f:
        json.dump(memory, f, indent=2, ensure_ascii=False)

memory = load_memory()
conversation_history = []  # list of {"role": "...", "content": "..."}

def update_memory_from_user_text(text: str):
    """
    Very simple personalization:
    - "my name is X" -> saves user_name
    - "i like Y" -> appends 'User likes Y' to facts
    """
    lower = text.lower()

    # Name extraction
    if "my name is " in lower:
        try:
            name_part = text[lower.index("my name is ") + len("my name is "):].strip()
            for sep in [".", ",", "!", "?"]:
                if sep in name_part:
                    name_part = name_part.split(sep)[0].strip()
            if name_part:
                memory["user_name"] = name_part
        except Exception:
            pass

    # Preference extraction
    if "i like " in lower:
        try:
            like_part = text[lower.index("i like ") + len("i like "):].strip()
            for sep in [".", ",", "!", "?"]:
                if sep in like_part:
                    like_part = like_part.split(sep)[0].strip()
            if like_part:
                memory["facts"].append(f"User likes {like_part}")
        except Exception:
            pass

    save_memory(memory)

def build_system_prompt():
    """Construct system prompt with personalization context."""
    name = memory.get("user_name")
    facts = memory.get("facts", [])
    memory_text = ""

    if name:
        memory_text += f"The user's name is {name}. "
    if facts:
        memory_text += "Known facts about the user: " + "; ".join(facts) + "."

    base = (
        "You are Jarvis, a polite, concise personal AI assistant. "
        "You speak in short, clear sentences. "
        "Be friendly and helpful. "
        "Use personal details only when they truly help the user. "
    )
    if memory_text:
        base += "Personalization context: " + memory_text
    return base

def ask_ai(user_text: str) -> str:
    """Send conversation to AI model and return reply text."""
    system_prompt = build_system_prompt()
    messages = [{"role": "system", "content": system_prompt}]
    # keep last few messages for context
    messages.extend(conversation_history[-6:])
    messages.append({"role": "user", "content": user_text})

    response = client.chat.completions.create(
        model=MODEL_NAME,
        messages=messages,
        temperature=0.6,
    )
    reply = response.choices[0].message.content.strip()

    conversation_history.append({"role": "user", "content": user_text})
    conversation_history.append({"role": "assistant", "content": reply})
    return reply

# ------------- SPEECH ENGINES -------------

recognizer = sr.Recognizer()
tts_engine = pyttsx3.init()

def speak(text: str, gui):
    """Speak text and keep GUI in sync."""
    gui.set_jarvis_text(text)
    gui.set_status("Speaking...")
    tts_engine.say(text)
    tts_engine.runAndWait()
    gui.set_status("Idle")

def listen(gui) -> str | None:
    """Listen once from microphone and return recognized text."""
    with sr.Microphone() as source:
        gui.set_status("Listening...")
        gui.set_user_text("")
        recognizer.adjust_for_ambient_noise(source, duration=0.5)
        audio = recognizer.listen(source)

    try:
        gui.set_status("Recognizing...")
        text = recognizer.recognize_google(audio, language="en-US")
        gui.set_user_text(text)
        gui.set_status("Idle")
        return text
    except sr.UnknownValueError:
        gui.set_status("Did not understand")
        return None
    except sr.RequestError as e:
        gui.set_status(f"Speech API error: {e}")
        return None

# ------------- TKINTER GUI -------------

class JarvisGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Jarvis AI Assistant")

        # Status
        self.status_label = tk.Label(root, text="Status: Idle", fg="green", font=("Arial", 11, "bold"))
        self.status_label.pack(pady=5)

        # User text
        tk.Label(root, text="You said:", font=("Arial", 10, "bold")).pack(anchor="w", padx=5)
        self.user_text = scrolledtext.ScrolledText(root, height=4, width=60, state="disabled")
        self.user_text.pack(padx=5, pady=5)

        # Jarvis text
        tk.Label(root, text="Jarvis:", font=("Arial", 10, "bold")).pack(anchor="w", padx=5)
        self.jarvis_text = scrolledtext.ScrolledText(root, height=8, width=60, state="disabled", wrap="word")
        self.jarvis_text.pack(padx=5, pady=5)

        # Buttons
        btn_frame = tk.Frame(root)
        btn_frame.pack(pady=10)

        self.listen_button = tk.Button(btn_frame, text="Listen", width=12, command=self.start_conversation_thread)
        self.listen_button.grid(row=0, column=0, padx=5)

        self.quit_button = tk.Button(btn_frame, text="Quit", width=12, command=root.destroy)
        self.quit_button.grid(row=0, column=1, padx=5)

        # Memory summary
        self.memory_label = tk.Label(root, text=self._memory_summary(), font=("Arial", 9, "italic"))
        self.memory_label.pack(pady=5)

        # Greet after window shows
        self.root.after(500, self._greet_user)

    def _memory_summary(self):
        name = memory.get("user_name")
        if name:
            return f"Known user: {name}"
        return "No personalized data yet. Say: 'My name is ...' or 'I like ...'"

    def _greet_user(self):
        if memory.get("user_name"):
            greet = f"Welcome back, {memory['user_name']}. Jarvis is online."
        else:
            greet = "Hello. I am Jarvis. Tell me your name and what you like."
        speak(greet, self)

    # --- GUI update helpers ---
    def set_status(self, text: str):
        self.status_label.config(text=f"Status: {text}")
        self.status_label.update_idletasks()

    def set_user_text(self, text: str):
        self.user_text.config(state="normal")
        self.user_text.delete("1.0", tk.END)
        self.user_text.insert(tk.END, text)
        self.user_text.config(state="disabled")
        self.user_text.update_idletasks()

    def set_jarvis_text(self, text: str):
        self.jarvis_text.config(state="normal")
        self.jarvis_text.delete("1.0", tk.END)
        self.jarvis_text.insert(tk.END, text)
        self.jarvis_text.config(state="disabled")
        self.jarvis_text.update_idletasks()

    # --- Conversation logic (non-blocking GUI) ---
    def start_conversation_thread(self):
        t = threading.Thread(target=self.conversation_once, daemon=True)
        t.start()

    def conversation_once(self):
        # 1) Listen from mic
        user_text = listen(self)
        if not user_text:
            return

        # 2) Update personalization
        update_memory_from_user_text(user_text)
        self.root.after(0, lambda: self.memory_label.config(text=self._memory_summary()))

        # 3) Ask AI
        try:
            self.set_status("Thinking...")
            reply = ask_ai(user_text)
        except Exception as e:
            reply = f"Sorry, there was an AI error: {e}"

        # 4) Speak reply
        speak(reply, self)

# ------------- RUN APP -------------

if __name__ == "__main__":
    root = tk.Tk()
    app = JarvisGUI(root)
    root.mainloop()
