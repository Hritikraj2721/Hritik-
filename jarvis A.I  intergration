

pip install speechrecognition pyaudio pyttsx3 openai
import os
import json
import threading
import speech_recognition as sr
import pyttsx3
import tkinter as tk
from tkinter import scrolledtext
from openai import OpenAI

# ------------- CONFIG -------------

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")  # set in your env
MODEL_NAME = "gpt-4o-mini"  # or any chat model you have access to

MEMORY_FILE = "jarvis_memory.json"

# ------------- AI CLIENT & MEMORY -------------

client = OpenAI(api_key=OPENAI_API_KEY)

def load_memory():
    if not os.path.exists(MEMORY_FILE):
        return {"user_name": None, "facts": []}
    try:
        with open(MEMORY_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {"user_name": None, "facts": []}

def save_memory(memory):
    with open(MEMORY_FILE, "w", encoding="utf-8") as f:
        json.dump(memory, f, indent=2, ensure_ascii=False)

memory = load_memory()

conversation_history = []  # list of {"role": "...", "content": "..."}


def update_memory_from_user_text(text: str):
    """
    Very simple rule-based personalization:
    - Detect patterns like 'my name is X'
    - Detect 'I like Y' and store as a fact
    """
    lower = text.lower()

    # Name extraction
    if "my name is " in lower:
        try:
            name_part = text[lower.index("my name is ") + len("my name is "):].strip()
            # Stop at punctuation
            for sep in [".", ",", "!", "?"]:
                if sep in name_part:
                    name_part = name_part.split(sep)[0].strip()
            if name_part:
                memory["user_name"] = name_part
        except Exception:
            pass

    # Preference extraction
    if "i like " in lower:
        try:
            like_part = text[lower.index("i like ") + len("i like "):].strip()
            for sep in [".", ",", "!", "?"]:
                if sep in like_part:
                    like_part = like_part.split(sep)[0].strip()
            if like_part:
                memory["facts"].append(f"User likes {like_part}")
        except Exception:
            pass

    save_memory(memory)


def build_system_prompt():
    name = memory.get("user_name")
    facts = memory.get("facts", [])
    memory_text = ""

    if name:
        memory_text += f"The user's name is {name}. "
    if facts:
        memory_text += "Known facts about the user: " + "; ".join(facts) + "."

    base = (
        "You are Jarvis, a polite, concise personal AI assistant. "
        "You speak in short, clear sentences. "
        "Always answer in a friendly way and remember personal details only if helpful. "
    )
    if memory_text:
        base += "Personalization context: " + memory_text
    return base


def ask_ai(user_text: str) -> str:
    system_prompt = build_system_prompt()
    messages = [{"role": "system", "content": system_prompt}]
    messages.extend(conversation_history[-6:])  # last few turns
    messages.append({"role": "user", "content": user_text})

    response = client.chat.completions.create(
        model=MODEL_NAME,
        messages=messages,
        temperature=0.6,
    )
    reply = response.choices[0].message.content.strip()

    conversation_history.append({"role": "user", "content": user_text})
    conversation_history.append({"role": "assistant", "content": reply})
    return reply

# ------------- SPEECH ENGINES -------------

recognizer = sr.Recognizer()
tts_engine = pyttsx3.init()

def speak(text: str, gui):
    gui.set_jarvis_text(text)
    gui.set_status("Speaking...")
    tts_engine.say(text)
    tts_engine.runAndWait()
    gui.set_status("Idle")

def listen(gui) -> str | None:
    with sr.Microphone() as source:
        gui.set_status("Listening...")
        gui.set_user_text("")
        recognizer.adjust_for_ambient_noise(source, duration=0.5)
        audio = recognizer.listen(source)

    try:
        gui.set_status("Recognizing...")
        text = recognizer.recognize_google(audio, language="en-US")
        gui.set_user_text(text)
        gui.set_status("Idle")
        return text
    except sr.UnknownValueError:
        gui.set_status("Did not understand")
        return None
    except sr.RequestError as e:
        gui.set_status(f"API error: {e}")
        return None

# ------------- TKINTER GUI -------------

class JarvisGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Jarvis AI Assistant")

        self.status_label = tk.Label(root, text="Status: Idle", fg="green", font=("Arial", 11, "bold"))
        self.status_label.pack(pady=5)

        tk.Label(root, text="You said:", font=("Arial", 10, "bold")).pack(anchor="w", padx=5)
        self.user_text = scrolledtext.ScrolledText(root, height=4, width=60, state="disabled")
        self.user_text.pack(padx=5, pady=5)

        tk.Label(root, text="Jarvis:", font=("Arial", 10, "bold")).pack(anchor="w", padx=5)
        self.jarvis_text = scrolledtext.ScrolledText(root, height=8, width=60, state="disabled", wrap="word")
        self.jarvis_text.pack(padx=5, pady=5)

        btn_frame = tk.Frame(root)
        btn_frame.pack(pady=10)

        self.listen_button = tk.Button(btn_frame, text="Listen", width=12, command=self.start_conversation_thread)
        self.listen_button.grid(row=0, column=0, padx=5)

        self.quit_button = tk.Button(btn_frame, text="Quit", width=12, command=root.destroy)
        self.quit_button.grid(row=0, column=1, padx=5)

        # Show who the user is (if known)
        self.memory_label = tk.Label(root, text=self._memory_summary(), font=("Arial", 9, "italic"))
        self.memory_label.pack(pady=5)

        self.root.after(500, self._greet_user)

    def _memory_summary(self):
        name = memory.get("user_name")
        if name:
            return f"Known user: {name}"
        return "No personalized data yet. Say: 'My name is ...'"

    def _greet_user(self):
        if memory.get("user_name"):
            greet = f"Welcome back, {memory['user_name']}. Jarvis is online."
        else:
            greet = "Hello. I am Jarvis. You can tell me your name and what you like."
        speak(greet, self)

    # --- GUI update helpers ---
    def set_status(self, text: str):
        self.status_label.config(text=f"Status: {text}")
        self.status_label.update_idletasks()

    def set_user_text(self, text: str):
        self.user_text.config(state="normal")
        self.user_text.delete("1.0", tk.END)
        self.user_text.insert(tk.END, text)
        self.user_text.config(state="disabled")
        self.user_text.update_idletasks()

    def set_jarvis_text(self, text: str):
        self.jarvis_text.config(state="normal")
        self.jarvis_text.delete("1.0", tk.END)
        self.jarvis_text.insert(tk.END, text)
        self.jarvis_text.config(state="disabled")
        self.jarvis_text.update_idletasks()

    # --- conversation logic in worker thread ---
    def start_conversation_thread(self):
        t = threading.Thread(target=self.conversation_once, daemon=True)
        t.start()

    def conversation_once(self):
        user_text = listen(self)
        if not user_text:
            return

        # Update memory (simple learning)
        update_memory_from_user_text(user_text)
        # Refresh memory label in GUI thread
        self.root.after(0, lambda: self.memory_label.config(text=self._memory_summary()))

        # Call AI (can take time, so stay in worker thread)
        try:
            self.set_status("Thinking...")
            reply = ask_ai(user_text)
        except Exception as e:
            reply = f"Sorry, there was an AI error: {e}"

        # Speak reply back in the same worker thread
        speak(reply, self)

# ------------- RUN APP -------------

if __name__ == "__main__":
    if not OPENAI_API_KEY:
        raise RuntimeError("Please set OPENAI_API_KEY environment variable first.")

    root = tk.Tk()
    app = JarvisGUI(root)
    root.mainloop()
